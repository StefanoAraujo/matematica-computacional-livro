== Noções Básicas dos Erros

:cap: cap1

.Objetivos do capítulo
____
Ao final deste capítulo você deverá ser capaz de:

* Representar números no computador;

* Converter números do sistema decimal a  binário, e vice-versa;

* Entender o conceito de Sistema de Ponto Flutuante Normalizado;

* Relacionar-se cada vez mais com os conceitos de erros absoluto e
  relativo, e as implicações destes tipos de erros num sistema de ponto
  flutuante;

* Realizar operações aritméticas com números de um sistema de ponto flutuante dado,
  e entender a propagação de seus erros.  
____


Em forma geral, a resolução de qualquer problema se inicia pela
observação, logo, usando conceitos que não serão estudados neste
livro, é possível concebê-lo em termos científicos, o que visa a
construção de um modelo matemático que deve representar da melhor
forma possível o problema em estudo. Este procedimento é conhecido
como fase de modelagem. A seguinte figura esquematiza as fases a
seguir para resolver um problema dado:

image::images/cap1/fases.eps[scaledwidth="80%"]

No entanto, nestas fases podem surgir imprecisões como:

... Simplificação do modelo matemático, necessário para a obtenção de um modelo matemático solúvel; 
... Erro de truncamento, devido à troca de uma série infinita por uma finita;
... Erro de arredondamento, devido à própria estrutura da máquina; 
... Erro na obtenção dos dados, dados imprecisos obtidos de experimentos ou arredondados na entrada;
... etc. 

A menos que algumas medidas sejam consideradas para contornar estas
imprecisões, estas implicarão na diminuição da precisão dos resultados
obtidos ou, ainda pior, na obtenção de resultados incorretos.

Portanto, neste capítulo, focaremos a nossa atenção no estudo dos
erros, que possam surgir na resolução de um determinado problema; 
tais como, os erros que surgem da representação dos números no
computador e os erros das operações aritméticas efetuadas entre eles. 

=== Representação dos números no computador


Na matématica temos que as seguintes afirmações são válidas:
[latexmath]
++++
\[2+3=5, \quad 2\times 3=6\quad \mbox{e}\quad \left( \sqrt{2}\right)^2 =2\]
++++

Logo, não é do outro mundo pensar que estas afirmações sejam
verdadeiras ou válidas também num computador. No entanto, a aritmética
executada por um computador é diferente daquela utilizada na
Matemática, isto é, num computador stardard, esperamos resultados
exatos para:

[latexmath]
++++
\[2+3=5\quad \mbox{e}\quad 2\times 3=6;\]
porém, não necessariamente obteremos de forma precisa que
\[\left( \sqrt{2}\right)^2 =2.\]
++++

Nesta seção compreenderemos o porquê desse fato, isto é, estudaremos a
aritmética com a qual trabalha um computador.


Desta forma, mesmo que, na matemática, existam números expressos com
uma quantidade infinita de algarismos, por exemplo:

[latexmath]
++++
\[\pi= 3.14159 26535\dots, \quad \sqrt{2}=1.4142135623\dots,\quad 
\frac{1}{3}=0.3333333333\dots,
\]
++++
no computador, estes números devem ser representados com apenas um
número fixo e finito de algarismos, o que implicará que tais números
não serão representados de forma exata, porém essas representações
deverão ser aceitáveis na maioria das situações.  Embora que, muitas
vezes, a aritmética usada no computador seja satisfatória, quase
sempre surgem problemas devido a essa limitação.

 
Mais ainda, comumente, os computadores trabalham os números reais
representando-os no sistema binário, diferentemente do sistema decimal
que normalmente usamos. De fato, quando introduzimos uma informação
numérica no computador, esta é automaticamente transformada em sua
representação binária, porém, em muitas situações, essa conversão pode
acarretar em erros, devido ao número limitado de algarismos que temos
a disposição. A implicação desse fato, é que o resultado de uma
simples operação aritmética entre números representados no computador
pode apresentar erros; para evitar isto nas próximas seções
aprenderemos a teoria necessária para conter os erros decorrentes
desses fatores.

 

=== Representação dos números reais no sistema decimal  e no sistema  binário

Como já foi mencionado acima, os computadores comumente trabalham com
o sistema binário, porém desde que nós estamos habituados a trabalhar
somente com o sistema decimal, é necessário saber como são representados os números em ambas bases, além de convertê-los de uma base para outra.  Por este motivo, nesta seção estudaremos e/ou
lembraremos como realizar a conversão de números do sistema binário para decimal, e vice-versa. Informação complementar sobre este assunto pode ser encontrada em _Introdução à Computação_ de Sousa Filho, G. F.
e Medeiros, E. S.

Então:
--
* Dado latexmath:[$(11010.000111)_2$], qual é sua representação decimal?
* Dado latexmath:[$271.375$], qual é sua representação binária?
--

No decorrer desta seção responderemos estas perguntas.

[NOTE]
.Nota 1.1
====
Desde que estamos habituados a trabalhar com o sistema decimal não é necessário pôr em evidência esta base no momento de representar os números, isto é
[latexmath]
++++
\[
271.375\equiv (271.375)_{10},\quad 10\equiv (10)_{10}\quad \mbox{e}\quad 0.349\equiv (0.349)_{10}.
\]
++++
Porém, quando necessário usaremos sem distinção qualquer uma destas representações.
====
 
Comecemos estudando e/ou lembrando a conversão de números inteiros. 

===== Conversão de um número inteiro da base 2 para a base 10

Para introduzir este assunto, lembremos que  na base decimal, cada posição representa uma potência de dez. Assim, latexmath:[$35728$] pode ser reescrito como:

[latexmath]
++++
\[
35728=3\times 10^4+5\times 10^3+7\times 10^2+2\times 10^1+8\times 10^0
\]
++++

Logo, na base binária podemos usar a mesma metodologia, ou seja, cada posição digital representará uma potência de dois. Assim, dado o número inteiro na base binária latexmath:[$(11010)_{2}$] temos que este pode ser reescrito da seguinte forma:

[latexmath]
++++
\[
\begin{array}{ccl}
(11010)_{2}&=& 1\times 2^4 + 1\times 2^3 +0\times 2^2 + 1\times  2^1 + 0 \times 2^0.\\
\end{array}
\]
No entanto, 
\[
2^4=16,\quad 2^3=8,\quad 2^2=4,\quad 2^1=2\quad \mbox{e}\quad 2^0=1
\]
Assim,
\[
1\times 2^4 + 1\times 2^3 +0\times 2^2 + 1\times  2^1 + 0 \times 2^0=1\times 16 + 1\times 8 +0\times 4 + 1\times  2 + 0 \times 1=16+8+0+2+0=26
\]
Portanto, desde que $26$ está na base decimal, 
\[
(11010)_{2}=(26)_{10}
\]
++++
Da mesma forma, para o múmero inteiro na base binária latexmath:[$(1111111)_{2}$], temos que:
[latexmath]
++++
\[
\begin{array}{ccl}
(111111)_{2}&=& 1\times 2^6+1\times 2^5+1\times 2^4 + 1\times 2^3 +1\times 2^2 + 1\times  2^1 + 1 \times 2^0\\
&=&1\times 64+1\times 32+1\times 16 + 1\times 8 +1\times 4 + 1\times  2 + 1 \times 1\\
&=& 64+32+16+8+4+2+1\\
&=&(127)_{10}.
\end{array}
\]
++++

[NOTE]
.Nota 1.2
====
De forma geral, dada uma base latexmath:[$\beta\geq 2$], um número
nesta base será representado por: 

[latexmath]
++++
\[
(a_{i} a_{i-1} \ldots a_2 a_1 a_0)_{\beta},\quad\mbox{com}\quad 0\leq a_j \leq (\beta-1),\quad j=0,\ldots, i,
\]
porém, cada posição digital deste número representará uma potência de $\beta$. Assim, ele pode ser reescrito da seguinte forma:
\[
(a_{i} a_{i-1} \ldots a_2 a_1 a_0)_{\beta}= a_{i}\times \beta^{i} + a_{i-1} \times \beta^{i-1} + \cdots +a_2 \times \beta^{2}+ a_1 \times \beta^{1} + a_0\times \beta^{0} = \sum\limits_{j=0}^{i} a_{j}\times \beta^{j}.
\]
++++

Logo, ao efetuar o somatório latexmath:[$\sum\limits_{j=0}^{i} a_{j}\times \beta^{j}$ o 
resultado já é um número decimal. Portanto,
da representação acima, dada uma base  $\beta\geq 2$, podemos
converter qualquer número expresso nesta base para sua representação
na base $10$].
====

Por outro lado,  

[latexmath]
++++
\[
\begin{array}{ccl}
(26)_{10} &=& 2\times (2\times (2\times (2\times 1+1)+0)+1)+0.
\end{array}
\]
e
\[
\begin{array}{ccl}
(127)_{10} &=& 2\times(2\times (2\times (2\times (2\times (2\times 1+1)+1)+1)+1)+1)+1.
\end{array}
\]
++++

Ou seja, vemos intuitivamente que temos uma forma alternativa de
converter um número da base binária para a base decimal, sem ter que trabalhar com as potências de latexmath:[$2$. Para sermos mais precisos, dado um número na base  $2$: $(a_{i}
a_{i-1} \ldots a_2 a_1 a_0)_{2}$ a sua representação na base $10$,
denotada por $b_0$], é pode ser obtida usando o seguinte algoritmo:

Algoritmo 1.1::

Passo 0: :::  Dado um número inteiro latexmath:[$(a_{i}a_{i-1} \ldots a_2 a_1 a_0)_{2}$] na base binária, faça 
+
[latexmath]
++++
\[
k=i \quad \mbox{e}\quad b_k=a_k.
\]
++++

Passo 1: :::  Se latexmath:[$k = 0$], *PARE*. A representação decimal de  latexmath:[$(a_{i}a_{i-1} \ldots a_2 a_1 a_0)_{2}$ é $b_0$].
+
Caso contrário, obtenha latexmath:[$b_{k-1}$] tal que:
+
[latexmath]
++++
\[
b_{k-1}= 2 \times b_{k}+a_{k-1}.
\]
++++

Passo 2: :::  
+
Faça latexmath:[$k=k-1$] e volte para o *Passo 1*.


.{zwsp}
====
Usando o *Algoritmo 1.1*  determinemos a representação decimal dos seguintes números binários:
[latexmath]
++++
\[
(10001)_{2}\quad \mbox{e}\quad  (10011010)_2.
\]
++++

Solução::

..  Fazendo latexmath:[$(10001)_{2}=(a_4a_3a_2a_1a_0)$], temos que
+
[latexmath]
++++
\[
k=4,3,2,1,0. 
\]
++++
+
Logo
+
--
* Para latexmath:[$k=4$ fazemos $b_4=a_4=1$. Desde que $k=4\neq 0 $]
+
[latexmath]
++++
\[
\begin{array}{cclclcl}
b_{3}&=& 2 \times b_{4}+a_{3} &=&  2\times 1  +0 &=& 2;
\end{array}
\]
++++
+
e agora latexmath:[$k=k-1=3$].

* Para latexmath:[$k=3$. Desde que $k=3\neq 0 $]
+
[latexmath]
++++
\[
\begin{array}{cclclcl}
b_{2}&=& 2 \times b_{3} +a_2&=&  2\times 2  +0 &=& 4;\\
\end{array}
\]
++++
+
e agora latexmath:[$k=k-1=2$].

* Para latexmath:[$k=2$. Desde que $k=2\neq 0 $]
+
[latexmath]
++++
\[
\begin{array}{cclclcl}
b_{1}&=& 2 \times b_{2} +a_1&=&  2\times 4  +0 &=& 8;\\
\end{array}
\]
++++
+
e agora latexmath:[$k=k-1=1$].

* Para latexmath:[$k=1$. Desde que $k=1\neq 0 $]
+
[latexmath]
++++
\[
\begin{array}{cclclcl}
b_{0}&=& 2 \times b_{1}+a_0 &=&  2\times 8 +1 &=& 17;
\end{array}
\]
++++
+
e agora latexmath:[$k=k-1=0$].

* Para latexmath:[$k=0$. Desde que $k=0$] Paramos!
--
+
Portanto, a representação decimal de latexmath:[$(10001)_{2}$ é $17$], isto é
+
[latexmath]
++++
\[
\begin{array}{cclclcl}
(10001)_{2}&=& (17)_{10}.
\end{array}
\]
++++


..  Fazendo latexmath:[$(10011010)_{2}=(a_7a_6a_5a_4a_3a_2a_1a_0)$], temos que
+
[latexmath]
++++
\[
k=7,6,5,4,3,2,1,0. 
\]
++++
+
Logo,
+
--
* Para latexmath:[$k=7$ fazemos $b_7=a_7=1$. Desde que $k=7\neq 0 $]
+
[latexmath]
++++
\[
\begin{array}{cclclcl}
b_{6}&=& 2 \times b_{7}+a_{6} &=&  2\times 1  +0 &=& 2;
\end{array}
\]
++++
+
e agora latexmath:[$k=k-1=6$].

* Para latexmath:[$k=6$. Desde que $k=6\neq 0 $]
+
[latexmath]
++++
\[
\begin{array}{cclclcl}
b_{5}&=& 2 \times b_{6} +a_5&=&  2\times 2  +0 &=& 4;\\
\end{array}
\]
++++
+
e agora latexmath:[$k=k-1=5$].

* Para latexmath:[$k=5$. Desde que $k=5\neq 0 $]
+
[latexmath]
++++
\[
\begin{array}{cclclcl}
b_{4}&=& 2 \times b_{5} +a_4&=&  2\times 4  +1 &=& 9;\\
\end{array}
\]
++++
+
e agora latexmath:[$k=k-1=4$].

* Para latexmath:[$k=4$. Desde que $k=4\neq 0 $]
+
[latexmath]
++++
\[
\begin{array}{cclclcl}
b_{3}&=& 2 \times b_{4}+a_3 &=&  2\times 9 +1 &=& 19;
\end{array}
\]
++++
+
e agora latexmath:[$k=k-1=3$].

* Para latexmath:[$k=3$. Desde que $k=3\neq 0 $]
+
[latexmath]
++++
\[
\begin{array}{cclclcl}
b_{2}&=& 2 \times b_{3}+a_2 &=&  2\times 19 +0 &=& 38;
\end{array}
\]
++++
+
e agora latexmath:[$k=k-1=2$].

* Para latexmath:[$k=2$. Desde que $k=2\neq 0 $]
+
[latexmath]
++++
\[
\begin{array}{cclclcl}
b_{1}&=& 2 \times b_{2}+a_1 &=&  2\times 38 +1 &=& 77;
\end{array}
\]
++++
+
e agora latexmath:[$k=k-1=1$].

* Para latexmath:[$k=1$. Desde que $k=1\neq 0 $]
+
[latexmath]
++++
\[
\begin{array}{cclclcl}
b_{0}&=& 2 \times b_{1}+a_0 &=&  2\times 77 +0 &=& 154;
\end{array}
\]
++++
+
e agora latexmath:[$k=k-1=0$].

* Para latexmath:[$k=0$. Desde que $k=0 $] Paramos!
--
+
Portanto, a representação decimal de latexmath:[$(10011010)_{2}$ é $154$], isto é
+
[latexmath]
++++
\[
\begin{array}{cclclcl}
(10011010)_{2}&=& (154)_{10}.
\end{array}
\]
++++



====



===== Conversão de um número inteiro da base 10 para a base 2

No seguinte exemplo, apresenta de forma intuitiva como obter um algoritmo para
converter um número da base decimal para a base binária.


.{zwsp}
====
Considere o número latexmath:[$b_0= 271$ e a sua representação
binária $(a_{i} a_{i-1} \ldots a_2 a_1 a_0)_{2}$], isto é,

[latexmath]
++++
\[
\begin{array}{rcl}
(271)_{10} &=&(a_{i} a_{i-1} \ldots a_2 a_1 a_0)_{2}
\end{array}
\]
Porém, 
\[
\begin{array}{rcl}
  (a_{i} a_{i-1} \ldots a_2 a_1 a_0)_{2}     &=& a_{i}\times 2^{i} + a_{i-1} \times 2^{i} + \cdots +a_2 \times 2^{2}+ a_1 \times 2^{1} + a_0\times 2^{0}\\
&=& 2 \times \left( a_{i}\times 2^{i-1} + a_{i-1} \times 2^{i-2} + \cdots +a_2 \times 2^{1}+ a_1 \times 2^{0}\right)  + a_0\end{array}
\]
Assim, 
\[
\begin{array}{rcl}
271&=& 2 \times 135 + 1.
\end{array}
\]
++++
Logo, latexmath:[$a_0=1$, e representa o resto da divisão de $271$ 
por $2$. Repetindo o processo para $b_1=135$] temos  que

[latexmath]
++++
\[
\begin{array}{rcl}
135    &=& a_{i}\times 2^{i-1} + a_{i-1} \times 2^{i-2} + \cdots a_2 \times 2^{1}+ a_1\\ 
       &=& 2 \times \left( a_{i}\times 2^{i-2} + a_{i-1} \times 2^{i-3} + \cdots a_2 \times 2^{0} \right) + a_1 \\
&=& 2 \times 67 + 1.
\end{array}
\]
++++

Assim, latexmath:[$a_1=1$, e representa o resto da divisão de
$b_1=135$ por $2$. Repetindo este processo sucessivamente obtemos os
seguintes $b_i'$s e $a_i'$]s:

[latexmath]
++++
\[
\begin{array}{lclcl}
b_0 =271 &=& 2\times 135 +1 &\Rightarrow& a_0 = 1;\\
b_1 =135 &=& 2\times 67  +1 &\Rightarrow& a_1 = 1;\\
b_2 =67  &=& 2\times 33  +1 &\Rightarrow& a_2 = 1;\\
b_3 =33  &=& 2\times 16  +1 &\Rightarrow& a_3 = 1;\\
b_4 =16  &=& 2\times 8   +0 &\Rightarrow& a_4 = 0;\\
b_5 =8   &=& 2\times 4   +0 &\Rightarrow& a_5 = 0;\\
b_6 =4   &=& 2\times 2   +0 &\Rightarrow& a_6 = 0;\\
b_7 =2   &=& 2\times 1   +0 &\Rightarrow& a_7 = 0;\\
b_8 =1   &=& 2\times 0   +1 &\Rightarrow& a_8 = 1.
\end{array}
\]
Portanto, 
\[
(271)_{10}= (100001111)_{2}.
\]
++++
====

Assim, para sermos mais precisos, dado um número inteiro latexmath:[$n$ na base
decimal, com  $(a_{i} a_{i-1} \ldots a_2 a_1 a_0)_{2}$, como sua
representação binária, podemos obter o dígito binário $a_k$ para cada
$k$, $k=0,1,\dots,i$], usando o seguinte algoritmo:

Algoritmo 1.2::

Passo 0: ::: Dado  um número inteiro latexmath:[$n$] na base
decimal, faça 
+
[latexmath]
++++
\[
k=0\quad \mbox{e}\quad n_k=n.
\]
++++

Passo 1: :::  Obtenha latexmath:[$q_k$ e $r_k$] tais que:
+
[latexmath]
++++
\[
n_k=2\times q_k + r_k.
\]
++++
+
Faça latexmath:[$a_k=r_k.$]

Passo 2: :::  Se latexmath:[$q_k = 0$], *PARE*.
+
Caso contrário, faça latexmath:[$n_{k+1}=q_k$], latexmath:[$k=k+1$] e volte para o *Passo 1*.

.{zwsp}
====
Usando o *Algoritmo 1.2*  determinemos a representação binária dos seguintes números decimais:
[latexmath]
++++
\[
37_{10}\quad \mbox{e}\quad  156_{10}.
\]
++++

Solução::


..  Para latexmath:[$n=37_{10}$, fazemos $k=0$ e $n_0=37_{10}$]. Logo
+
--
* Para latexmath:[$k=0$, precisamos obter $q_0$ e $r_0$] tais que
+
[latexmath]
++++
\[
37=2\times q_0+r_0
.
\]
Desde que
\[
37=2 \times 18+1\quad \Rightarrow\quad q_0=18 \quad \mbox{e}\quad r_0=1=a_0.
\]
++++
+
Como latexmath:[$q_0 \neq 0$, fazemos $n_1=q_0=18$, $k=k+1=1$];

* Para latexmath:[$k=1$, precisamos obter $q_1$ e $r_1$] tais que
+
[latexmath]
++++
\[
18=2\times q_1+r_1
.
\]
Desde que
\[
18=2 \times 9+0\quad \Rightarrow\quad q_1=9 \quad \mbox{e}\quad r_1=0=a_1.
\]
++++
+
Como latexmath:[$q_1 \neq 0$, fazemos $n_2=q_1=9$, $k=k+1=2$];

* Para latexmath:[$k=2$, precisamos obter $q_2$ e $r_2$] tais que
+
[latexmath]
++++
\[
9=2\times q_2+r_2
.
\]
Desde que
\[
9=2 \times 4+1\quad \Rightarrow\quad q_2=4 \quad \mbox{e}\quad r_2=1=a_2.
\]
++++
+
Como latexmath:[$q_2 \neq 0$, fazemos $n_3=q_2=4$, $k=k+1=3$];

* Para latexmath:[$k=3$, precisamos obter $q_3$ e $r_3$] tais que
+
[latexmath]
++++
\[
4=2\times q_3+r_3
.
\]
Desde que
\[
4=2 \times 2+0\quad \Rightarrow\quad q_3=2 \quad \mbox{e}\quad r_3=0=a_3.
\]
++++
+
Como latexmath:[$q_3 \neq 0$, fazemos $n_4=q_3=2$, $k=k+1=4$];

* Para latexmath:[$k=4$, precisamos obter $q_4$ e $r_4$] tais que
+
[latexmath]
++++
\[
2=2\times q_4+r_4
.
\]
Desde que
\[
2=2 \times 1+0\quad \Rightarrow\quad q_4=1 \quad \mbox{e}\quad r_4=0=a_4.
\]
++++
+
Como latexmath:[$q_4 \neq 0$, fazemos $n_5=q_4=1$, $k=k+1=5$];

* Para latexmath:[$k=5$, precisamos obter $q_5$ e $r_5$] tais que
+
[latexmath]
++++
\[
1=2\times q_5+r_5
.
\]
Desde que
\[
1=2 \times 0+1\quad \Rightarrow\quad q_5=0 \quad \mbox{e}\quad r_5=1=a_5.
\]
++++
+
Como latexmath:[$q_5 = 0$], paramos!
--
+
Portanto, 
+
[latexmath]
++++
\[
\begin{array}{cclclcl}
37_{10}&=& (a_5a_4a_3a_2a_1a_0)_{2}=(100101)_2.
\end{array}
\]
++++

..  Para latexmath:[$n=156_{10}$, fazemos $k=0$ e $n_0=156_{10}$]. Logo
+
--
* Para latexmath:[$k=0$, precisamos obter $q_0$ e $r_0$] tais que
+
[latexmath]
++++
\[
156=2\times q_0+r_0
.
\]
Desde que
\[
156=2 \times 78+0\quad \Rightarrow\quad q_0=78 \quad \mbox{e}\quad r_0=0=a_0.
\]
++++
+
Como latexmath:[$q_0 \neq 0$, fazemos $n_1=q_0=78$, $k=k+1=1$];

* Para latexmath:[$k=1$, precisamos obter $q_1$ e $r_1$] tais que
+
[latexmath]
++++
\[
78=2\times q_1+r_1
.
\]
Desde que
\[
78=2 \times 39+0\quad \Rightarrow\quad q_1=39 \quad \mbox{e}\quad r_1=0=a_1.
\]
++++
+
Como latexmath:[$q_1 \neq 0$, fazemos $n_2=q_1=39$, $k=k+1=2$];

* Para latexmath:[$k=2$, precisamos obter $q_2$ e $r_2$] tais que
+
[latexmath]
++++
\[
39=2\times q_2+r_2
.
\]
Desde que
\[
39=2 \times 19+1\quad \Rightarrow\quad q_2=19 \quad \mbox{e}\quad r_2=1=a_2.
\]
++++
+
Como latexmath:[$q_2 \neq 0$, fazemos $n_3=q_2=19$, $k=k+1=3$];

* Para latexmath:[$k=3$, precisamos obter $q_3$ e $r_3$] tais que
+
[latexmath]
++++
\[
19=2\times q_3+r_3
.
\]
Desde que
\[
19=2 \times 9+1\quad \Rightarrow\quad q_3=9 \quad \mbox{e}\quad r_3=1=a_3.
\]
++++
+
Como latexmath:[$q_3 \neq 0$, fazemos $n_4=q_3=9$, $k=k+1=4$];

* Para latexmath:[$k=4$, precisamos obter $q_4$ e $r_4$] tais que
+
[latexmath]
++++
\[
9=2\times q_4+r_4
.
\]
Desde que
\[
9=2 \times 4+1\quad \Rightarrow\quad q_4=4 \quad \mbox{e}\quad r_4=1=a_4.
\]
++++
+
Como latexmath:[$q_4 \neq 0$, fazemos $n_5=q_4=4$, $k=k+1=5$];

* Para latexmath:[$k=5$, precisamos obter $q_5$ e $r_5$] tais que
+
[latexmath]
++++
\[
4=2\times q_5+r_5
.
\]
Desde que
\[
4=2 \times 2+0\quad \Rightarrow\quad q_5=2 \quad \mbox{e}\quad r_5=0=a_5.
\]
++++
+
Como latexmath:[$q_5 \neq 0$, fazemos $n_6=q_5=4$, $k=k+1=6$];

* Para latexmath:[$k=6$, precisamos obter $q_6$ e $r_6$] tais que
+
[latexmath]
++++
\[
2=2\times q_6+r_6
.
\]
Desde que
\[
2=2 \times 1+0\quad \Rightarrow\quad q_6=1 \quad \mbox{e}\quad r_6=0=a_6.
\]
++++
+
Como latexmath:[$q_6 \neq 0$, fazemos $n_7=q_6=2$, $k=k+1=7$];


* Para latexmath:[$k=7$, precisamos obter $q_7$ e $r_7$] tais que
+
[latexmath]
++++
\[
1=2\times q_7+r_7
.
\]
Desde que
\[
1=2 \times 0+1\quad \Rightarrow\quad q_7=0 \quad \mbox{e}\quad r_7=1=a_7.
\]
++++
+
Como latexmath:[$q_7 = 0$], paramos!
--
+
Portanto, 
+
[latexmath]
++++
\[
\begin{array}{cclclcl}
156_{10}&=& (a_7a_6a_5a_4a_3a_2a_1a_0)_{2}=(10011100)_2.
\end{array}
\]
++++


====

===== Conversão de um número fracionário da base 10 para a base 2

Vejamos agora como converter um número fracionário da base
latexmath:[$10$] para a base binária.

[IMPORTANT]
.Importante 1.1
====
Dado um número latexmath:[$n\in \mathbb{R}$. Se $n$] é fracionário, então ele será fracionário em qualquer base.
====

.{zwsp} 
====
Consideremos o número latexmath:[$n=0.375$, logo, da nota acima, existem dígitos
binários $d_1,d_2,\ldots,d_i,\ldots$], tais que:

[latexmath]
++++
\[n=0.375=(0.d_1d_2\ldots d_i \ldots)_2.
\]
Mais ainda,
\[
(0.375)_{10}= (0.d_1d_2\ldots d_i \ldots)_2= d_1 \times 2^{-1} + d_2\times 2^{-2} + \cdots + d_i \times 2^{-i} +\cdots
\]
++++

Agora, se multiplicamos cada termo da expressão acima por latexmath:[$2$] obtemos:
[latexmath]
++++
\[
2\times 0.375 = 0.75= 0+ 0.75= d_1  + d_2\times 2^{-1} + d_3\times 2^{-2} +\cdots + d_i \times 2^{-i+1} +\cdots
\]
++++
Logo, latexmath:[$d_1$ representa a parte inteira de $2\times 0.375=0.75$, porém $0.75$ não tem parte inteira, implicando que $d_1=0$] e
[latexmath]
++++
\[
0.75 = d_2\times 2^{-1} + d_3\times 2^{-2} +\cdots + d_i \times 2^{-i+1} +\cdots
\]
++++

Repetindo novamente este procedimento para latexmath:[$0.75$] temos que:

[latexmath]
++++
\[
2\times 0.75 = 1.5= 1+ 0.5= d_2 + d_3\times 2^{-1}+d_4\times 2^{-2} +\cdots + d_i \times 2^{-i+2} +\cdots
\]
++++
Logo, latexmath:[$d_2$ representa a parte inteira de $2\times 0.75=1.5$, como $1$ é a parte inteira de $1.5$, resulta que  $d_2=1$] e
[latexmath]
++++
\[
0.5 = d_3\times 2^{-1}+d_4\times 2^{-2} +\cdots + d_i \times 2^{-i+2} +\cdots
\]
++++

Repetindo novamente o procedimento para o número latexmath:[$0.5$] temos que:

[latexmath]
++++
\[
2\times 0.5 = 1.0= 1+ 0.0= d_3 +d_4\times 2^{-1} +\cdots + d_i \times 2^{-i+3} +\cdots
\]
++++

Assim, latexmath:[$d_3=1$ representa a parte inteira de $2\times 0.5=1$] e 
[latexmath]
++++
\[
0.0 = d_4\times 2^{-1} +\cdots + d_i \times 2^{-i+3} +\cdots
\]
++++

Como a parte fracionária é zero, o processo termina. Assim, latexmath:[$d_1=0$, $d_2=1$,
$d_3=1$]. Portanto,  

[latexmath]
++++
\[
(0.375)_{10}= (0.011)_2.
\]
++++
====

[NOTE]
.Nota 1.3
====
No exemplo acima, vimos que latexmath:[$n=0.375$] tem uma
representação finita na base binária, porém isto  não necessariamente
é verdadeiro na maioria dos casos. De forma geral, dado um número
latexmath:[$n\in (0,1)$, embora este tenha representação finita no sistema
decimal, a sua representação na base $2$] pode ser finita ou infinita. Este fato será ilustrado no próximo exemplo.

====
	

De forma geral, dado um número latexmath:[$0<n<1$ no
sistema decimal. Então, $(0.d_1 d_2 \ldots d_i \ldots)_2$], sua
representação binária é obtida, dígito a dígito, usando o
seguinte algoritmo:

Algoritmo 1.3::

Passo 0: ::: Dado um número latexmath:[$0<n<1$], faça 
+
[latexmath]
++++
\[
k=1\quad \mbox{e}\quad r_1=n.
\]
++++
Passo 1: :::  Calcule latexmath:[$p_k=2 \times r_k$].
+
--
* Se latexmath:[$p_k \geq 1$, faça $d_k=1$];
* Caso contrário, faça latexmath:[$d_k=0$].
--

Passo 2: ::: Faça latexmath:[ $r_{k+1} = p_k -d_k$].
+
--
* Se latexmath:[$r_{k+1}=0$], *PARE*; 
* Caso contrário, faça latexmath:[$k=k+1$] e volte para o *Passo 1*.
--
 

[NOTE]
.Nota 1.4
====
Da nota anterior, o *Algoritmo 1.3* pode ou não parar após um número finito de iterações. 
====

.{zwsp} 
====
Usando o *Algoritmo 1.3* determinemos a representação binária dos seguintes números fracionários decimais:
[latexmath]
++++
\[
0.171875_{10}\quad \mbox{e} \quad 0.2_{10}
\]
++++
Solução:: 

.. Para  latexmath:[$n=0.171875_{10}$, façamos $k=1$ e $r_1=0.171875$]. Logo
+
--
* Para latexmath:[$k=1$, calculamos $p_1$]. Desde que
+
[latexmath]
++++
\[
p_1=2\times r_1=2\times 0.171875=0.34375 < 1\quad \Rightarrow \quad d_1=0 \quad \mbox{e} \quad r_2=p_1-d_1=0.34375.
\]
++++
+
Como latexmath:[$r_2\neq 0$, fazemos $k=k+1=2$].

* Para latexmath:[$k=2$, calculamos $p_2$]. Desde que
+
[latexmath]
++++
\[
p_2=2\times r_2=2\times 0.34375=0.6875 < 1\quad \Rightarrow \quad d_2=0 \quad \mbox{e} \quad r_3=p_2-d_2=0.6875.
\]
++++
+
Como latexmath:[$r_3\neq 0$, fazemos $k=k+1=3$].

* Para latexmath:[$k=3$, calculamos $p_3$]. Desde que
+
[latexmath]
++++
\[
p_3=2\times r_3=2\times 0.6875=1.375 > 1\quad \Rightarrow \quad d_3=1 \quad \mbox{e} \quad r_4=p_3-d_3=0.375.
\]
++++
+
Como latexmath:[$r_4\neq 0$, fazemos $k=k+1=4$].

* Para latexmath:[$k=4$, calculamos $p_4$]. Desde que
+
[latexmath]
++++
\[
p_4=2\times r_4=2\times 0.375=0.75< 1\quad \Rightarrow \quad d_4=0 \quad \mbox{e} \quad r_5=p_4-d_4=0.75.
\]
++++
+
Como latexmath:[$r_5\neq 0$, fazemos $k=k+1=5$].

* Para latexmath:[$k=5$, calculamos $p_5$]. Desde que
+
[latexmath]
++++
\[
p_5=2\times r_5=2\times 0.75=1.5 > 1\quad \Rightarrow \quad d_5=1 \quad \mbox{e} \quad r_6=p_5-d_5=0.5.
\]
++++
+
Como latexmath:[$r_6\neq 0$, fazemos $k=k+1=6$].

* Para latexmath:[$k=6$, calculamos $p_6$]. Desde que
+
[latexmath]
++++
\[
p_6=2\times r_6=2\times 0.5=1.0 \geq 1\quad \Rightarrow \quad d_6=1 \quad \mbox{e} \quad r_7=p_6-d_6=0.
\]
++++
+
Como latexmath:[$r_7= 0$], Paramos!.
--
+
Portanto,
+
[latexmath]
++++
\[
0.171875_{10} = (0.001011)_2.
\]
++++

.. Para  latexmath:[$n=0.2_{10}$, façamos $k=1$ e $r_1=0.2$]. Logo
+
--
* Para latexmath:[$k=1$, calculamos $p_1$]. Desde que
+
[latexmath]
++++
\[
p_1=2\times r_1=2\times 0.2=0.4 < 1\quad \Rightarrow \quad d_1=0 \quad \mbox{e} \quad r_2=p_1-d_1=0.4.
\]
++++
+
Como latexmath:[$r_2\neq 0$, fazemos $k=k+1=2$].

* Para latexmath:[$k=2$, calculamos $p_2$]. Desde que
+
[latexmath]
++++
\[
p_2=2\times r_2=2\times 0.4=0.8 < 1\quad \Rightarrow \quad d_2=0 \quad \mbox{e} \quad r_3=p_2-d_2=0.8.
\]
++++
+
Como latexmath:[$r_3\neq 0$, fazemos $k=k+1=3$].

* Para latexmath:[$k=3$, calculamos $p_3$]. Desde que
+
[latexmath]
++++
\[
p_3=2\times r_3=2\times 0.8=1.6 > 1\quad \Rightarrow \quad d_3=1 \quad \mbox{e} \quad r_4=p_3-d_3=0.6.
\]
++++
+
Como latexmath:[$r_4\neq 0$, fazemos $k=k+1=4$].

* Para latexmath:[$k=4$, calculamos $p_4$]. Desde que
+
[latexmath]
++++
\[
p_4=2\times r_4=2\times 0.6=1.2 > 1\quad \Rightarrow \quad d_4=1 \quad \mbox{e} \quad r_5=p_4-d_4=0.2.
\]
++++
+
Como latexmath:[$r_5\neq 0$, fazemos $k=k+1=5$].

* Para latexmath:[$k=5$, notemos que $r_5=r_1$], ou seja, os valores obtidos acima serão repetido de foma periódica.
--
+
Mais ainda,  latexmath:[$0.2=r_1=r_5=r_9=r_{13}\dots$] e
assim por diante.  Portanto,
+
[latexmath]
++++
\[
0.2_{10} = (0.001100110011\ldots)_2=(0.\overline{0011})_2.
\]
++++


====

[CAUTION]
.Atenção 1.1
====
A situação vista no exemplo acima, isto é, dado um número na base
decimal com representação finita e com representação infinita na base
binária, pode gerar erros, não detectáveis por nós, nos resultados
obtidos usando  sistemas computacionais que trabalhem no sistema
binário.  De fato,  latexmath:[$(0.2)_{10}$] será armazenado de forma
aproximada  no computador, devido que o computador possui uma
quantidade fixa e finita de posições para armazenar os dígitos da
mantissa de um número, e tal aproximação será usada para realizar os
cálculos. Portanto, não podemos esperar um resultados exatos quando
trabalhamos com números desta classe. 

====

===== Conversão de um número fracionário da base 2 para a base 10

Dado um número fracionário na base 2, denotado por latexmath:[$(r)_2$], isto é,
[latexmath]
++++
\[
(r)_2=(0.d_1 d_2 \ldots d_i \ldots)_2
\]
++++
obteremos a sua representação na base decimal. 

O algoritmo que apresentaremos para fazer esta transformação é
equivalente ao descrito previamente. Inicialmente definimos
latexmath:[$r_1=r$, e em cada iteração $k$, o processo multiplica o
número $r_k$ por $(10)_{10} = (1010)_2$ para obter o dígito $b_k$,
onde $b_k$] é a parte inteira deste produto convertida para a base
decimal. Notemos que essas operações devem ser realizadas no sistema
binário.


Algoritmo 1.4::

Passo 0: ::: Dado latexmath:[$(r)_2$], faça  
+
[latexmath]
++++
\[
k=1\quad \mbox{e}\quad r_1=(r)_2.
\]
++++
Passo 1:::  Calcule latexmath:[$w_k=(1010)_2 \times r_k$]. + 
Seja latexmath:[$z_k$] a parte inteira de latexmath:[$w_k$]. +
Faça latexmath:[$b_k$]  igual à conversão de latexmath:[$z_k$] para a base 10.

Passo 2: ::: Faça latexmath:[$r_{k+1} = w_k -z_k$].
+
--
* Se latexmath:[$r_{k+1}=0$], *PARE*.
* Caso contrário, faça latexmath:[$k=k+1$] e volte para o *Passo 1*.
--
   
.{zwsp} 
==== 
Usando o *Algoritmo 1.4* determinemos a representação em base 10 de  latexmath:[$(0.000111)_2$],. 

Solução::
Fazendo latexmath:[$k=1$ e $r_1=(r)_2 = (0.000111)_2$], temos que:
+
--
* Para latexmath:[$k=1$, calculamos $w_1$]. 
+
Desde que
+
[latexmath]
++++
\[
\begin{array}{rcl}
w_1&=&(1010)_2\times r_1=(1010)_2\times(0.000111)_2\\\\
&=&(1010)_2\times(111)_2\times 2^{-6}=(1000110)_2\times 2^{-6}\\\\
&=&(1.000110)_2 =(1.00011)_2 
\end{array}
\]
se segue que
\[
 z_1=(1)_2 , \quad r_2=w_1-z_1=(0.00011)_2\quad \mbox{e}\quad b_1=1.
\]
++++
+
Como latexmath:[$r_2\neq 0$, fazemos $k=k+1=2$].

* Para latexmath:[$k=2$, calculamos $w_2$]. 
+
Desde que
+
[latexmath]
++++
\[\begin{array}{rcl}
w_2&=&(1010)_2\times r_2=(1010)_2\times(0.00011)_2\\\\
&=&(1010)_2\times(11)_2\times 2^{-5}=(11110)_2\times 2^{-5}\\\\
&=&(0.11110)_2=(0.1111)_2  
\end{array}
\]
se segue que
\[
 z_2=(0)_2 , \quad r_3=w_2-z_2=(0.1111)_2\quad \mbox{e}\quad b_2=0.
\]
++++
+
Como latexmath:[$r_3\neq 0$, fazemos $k=k+1=3$].

* Para latexmath:[$k=3$, calculamos $w_3$]. 
+
Desde que
+
[latexmath]
++++
\[\begin{array}{rcl}
w_3&=&(1010)_2\times r_3=(1010)_2\times(0.1111)_2\\\\
&=&(1010)_2\times(1111)_2\times 2^{-4}=(10010110)_2\times 2^{-4} \\\\
&=&(1001.0110)_2 =(1001.011)_2 
\end{array}\]
se segue que
\[
 z_3=(1001)_2 , \quad r_4=w_3-z_3=(0.011)_2\quad \mbox{e}\quad b_3=9.
\]
++++
+
Como latexmath:[$r_4\neq 0$, fazemos $k=k+1=4$].

* Para latexmath:[$k=4$, calculamos $w_4$]. 
+
Desde que
+
[latexmath]
++++
\[\begin{array}{rcl}
w_4&=&(1010)_2\times r_4=(1010)_2\times(0.011)_2\\\\
&=&(1010)_2\times(11)_2\times 2^{-3}=(11110)_2\times 2^{-3}\\\\
&=&(11.110)_2=(11.11)_2 
\end{array}
\]
se segue que
\[ z_4=(11)_2 , \quad r_5=w_4-z_4=(0.11)_2\quad \mbox{e}\quad b_4=3.
\]
++++
+
Como latexmath:[$r_5\neq 0$, fazemos $k=k+1=5$].

* Para latexmath:[$k=5$, calculamos $w_5$]. 
+
Desde que
+
[latexmath]
++++
\[\begin{array}{rcl}
w_5&=&(1010)_2\times r_5=(1010)_2\times(0.11)_2\\\\
&=&(1010)_2\times(11)_2\times 2^{-2}=(11110)\times 2^{-2}\\\\
&=&(111.10)_2=(111.1)_2 
\end{array}\]
se segue que
\[ z_5=(111)_2 , \quad r_6=w_5-z_5=(0.1)_2\quad \mbox{e}\quad b_5=7.
\]
++++
+
Como latexmath:[$r_6\neq 0$, fazemos $k=k+1=6$].

* Para latexmath:[$k=6$, calculamos $w_6$]. 
+
Desde que
+
[latexmath]
++++
\[\begin{array}{rcl}
w_6&=&(1010)_2\times r_6=(1010)_2\times(0.1)_2\\\\
&=&(1010)_2\times(1)_2\times 2^{-1}=(1010)_2\times 2^{-1}\\\\
&=&(101.0)_2 =(101)_2 
\end{array}
\]
se segue que
\[ z_6=(101)_2 , \quad r_7=w_6-z_6=(0)_2\quad \mbox{e}\quad b_6=5.
\]
++++
+
Como latexmath:[$r_7= 0$], Paramos!
--
+
Portanto,
+
[latexmath]
++++
\[
(0.000111)_2 = 0.109375_{10}.
\]
++++
====




Assim, na seguinte caixa respondemos à pergunta feita no início desta
seção, além disso, ilustraremos isto com o próximo exemplo.

[IMPORTANT]
.Importante 1.2
====
Se o número em questão tem uma parte inteira e uma parte fracionária,
então a sua conversão, em outra base, será obtida decompondo esse na
soma da parte inteira com a parte fracionária, logo aplicaremos os
algoritmos respectivos a cada parte. 

====

.{zwsp}
====
.. Dado o número latexmath:[$ (271.375)_{10}$], determinemos a sua
   representação em base 2.

Solução::
Desde que
+
[latexmath]
++++
\[
(271.375)_{10}=(271)_{10}+(0.375)_{10}.
\]
Do {\bf Exemplos 1.2} e {\bf 1.4}, temos que
\[
(271)_{10}=(100001111)_2 \quad \mbox{e} \quad (0.375)_{10}=(0.001)_2,
\]
respectivamente. Portanto
\[
(271.375)_{10}=(100001111)_2 +(0.001)_2=(100001111.001)_2.
\]
++++

.. Dado o número latexmath:[$ (11010.000111)_2$], determinemos a sua
   representação em base 10. 

Solução::
Desde que
+
[latexmath]
++++
\[
(11010.000111)_2=(11010)_2+(0.000111)_2.
\]
Do {\bf Exemplo 1.1(a)} e o exemplo anterior, temos que
\[
(11010)_2=(26)_{10} \quad \mbox{e} \quad (0.000111)_2=(0.109375)_{10},
\]
respectivamente. Portanto
\[
(11010.000111)_2=(26)_{10}+(0.109375)_{10}=(26.109375)_{10}.
\]
++++


====


=== Sistema de Ponto Flutuante Normalizado

Como mencionado previamente, temos um número fixo e finito de espaço
para armazenar os números reais num computador, por este motivo,
apenas um subconjunto será representado exatamente, e  qualquer outro
fora deste subconjunto terá uma representação aproximada. Desta forma,
a seguinte definição estabelece teoricamente como é feita essa
representação.

Definição 1.1:: Sejam  latexmath:[$\beta\geq 2$, $n \in \mathbb{N}$, $\exp_{{\rm min}}\leq 0$ e $\exp_{{\rm max}}\geq 1$ inteiros. O {\bf Sistema de Ponto Flutuante Normalizado}, denotado por $ {\rm SPF}(\beta,n,\exp_{{\rm min}}, \exp_{{\rm max}})$], é definido por: 
+
[latexmath]
++++
\[
{\rm SPF}(\beta,n,\exp_{{\rm min}}, \exp_{{\rm max}}):=\{x \in \mathbb{R}:x=\pm (0.d_1 d_2 \ldots d_n)\times \beta^{{\rm exp}} \}
\]
++++
+
onde: 
+
--
* latexmath:[$\beta \geq 2$] é a base do sistema;

* latexmath:[$n$] é o número de dígitos na mantissa; 
+
[latexmath]
++++
\[
0\leq d_i \leq (\beta-1), \quad i=1,\ldots, n,\quad\mbox{com}\quad d_1 \neq 0;
\]
++++

* latexmath:[${\rm exp}$ é o expoente no intervalo $[{\rm exp}_{{\rm
  min}}, {\rm exp}_{{\rm max}}\]$].
--
+
Mais ainda, cada elemento desse conjunto é denominado de *ponto flutuante normalizado*, e como latexmath:[$d_1 \neq 0$], o *zero* é representado da seguinte forma:
+
[latexmath]
++++
\[
\mbox{\bf zero}= 0.\underbrace{000000\ldots 0}_{n\,\,\mbox{vezes}} \times \beta^{\exp_{\rm min}} .
\]
++++

Definição 1.2:: Seja latexmath:[${\rm SPF}(\beta,n,\exp_{{\rm min}}, \exp_{{\rm max}})$]. Então:
+
--
... O *menor número positivo exatamente representável*, denotado por latexmath:[${\rm m}$],  é dado por:
+
[latexmath]
++++
\[
{\rm m}= (0.1\underbrace{000000\ldots 0}_{(n-1)\,\,\mbox{vezes}}))_\beta \times \beta^{\exp_{\rm min}}=\beta^{\exp_{\rm min}-1};
\]
++++
... O *maior número positivo exatamente representável*, denotado por latexmath:[${\rm M}$], é dado por:
+
[latexmath]
++++
\[
{\rm M}= (0 . \underbrace{[\beta-1][\beta-1]\ldots [\beta-1]}_{n-\mbox{vezes}})_\beta \times \beta^{\exp_{\rm max}} 
=(\beta^n-1)\times\beta^{\exp_{\rm max}-n};\]
++++
... O *número máximo de mantissas positivas possíveis*, denotado por latexmath:[${\rm mantissas_{poss}}$], é dado por:
+
[latexmath]
++++
\[
{\rm mantissas}_{\rm poss}= (\beta-1) \times \beta^{n-1} ;
\]
++++
... O *número máximo de expoentes possíveis*, denotado por latexmath:[$\exp_{\rm poss}$], é dado por:
+
[latexmath]
++++
\[
\exp_{\rm poss}= \exp_{\rm max} - \exp_{\rm min} +1;
\]
++++
...  O *número de elementos positivos representáveis*, denotado por latexmath:[${\rm NumR}_{+}$], é dado por:
+
[latexmath]
++++
\[
{\rm NumR}_{+}=\mbox{mantissas}_{\rm poss} \times \exp_{\rm poss};
\]
++++

... o *número total de elementos
   representáveis*, denotado por latexmath:[${\rm NumR}_{\rm T}$], é dado por:
+
[latexmath]
++++
\[
{\rm NumR}_{\rm T} = 2\times {\rm NumR}_{+}+1.
\]
++++
--

////
[NOTE]
Os números $(0.1\underbrace{000000\ldots 0}_{(n-1)\,\,\mbox{vezes}}))$ e (0 . \underbrace{[\beta-1][\beta-1]\ldots [\beta-1]}_{n-\mbox{vezes}})_\beta estão na base $\beta$, por isto 

////

[CAUTION]
.Atenção 1.2
====
Dado latexmath:[$x \in \mathbb{R}$]. Então:

.. Se latexmath:[$x\in{\rm SPF}(\beta,n,\exp_{{\rm min}}, \exp_{{\rm max}})$], então  latexmath:[$-x\in{\rm SPF}(\beta,n,\exp_{{\rm min}}, \exp_{{\rm max}})$];

.. Se  latexmath:[$0<|x| < {\rm m}$, então $x$ não pode ser representado  em ${\rm SPF}(\beta,n,\exp_{{\rm min}}, \exp_{{\rm max}})$]. Nesta  situação o sistema acusará *underflow*;

.. Se latexmath:[$|x| > {\rm M}$,  então $x$ não pode ser representado em ${\rm SPF}(\beta,n,\exp_{{\rm min}}, \exp_{{\rm max}})$]. Nesta  situação o sistema acusará *overflow*. 

====

Os seguintes exemplos ilustram cada um dos conceitos estabelecidos na *Definição 1.2*, para latexmath:[$\beta=2$ e $10$].

.{zwsp}
====
.. Se consideramos latexmath:[$\beta=2$, $n=3$, $\exp_{\rm min}=-1$ e $\exp_{\rm max}=3$].   Então, temos que:
+
[latexmath]
++++
\[
{\rm SPF}(2,3,-1,3) =\left\{x \in \mathbb{R}: x=\pm 0.d_1 d_2 d_3 \times 2^{\exp} \right\}.
\] 
onde
\[
 d_i \in\{0,1\}, \mbox{ para } i=2,3 , \quad d_1=1, \quad \exp \in [-1,3].
\]
++++ 
+
Logo,
+
--
* latexmath:[${\rm m}=0.100_2 \times 2^{-1} =2^{-1}\times 2^{-1} =\frac{1}{4}$];  
* latexmath:[${\rm M}=0.111_2 \times 2^{3} = \left(2^{-1}+2^{-2}+2^{-3}\right)\times 2^3=\frac{7}{8}\times 2^3 =7$];
* latexmath:[${\rm mantissas}_{\rm poss}=(2-1)\times 2^{3-1} = 4$];
+
[latexmath]
++++
\[
0.100_2 =\frac{1}{2}, \quad 0.101_2  =\frac{5}{8}, \quad 0.110_2 =\frac{3}{4} \quad \mbox{e}\quad 0.111_2 =\frac{7}{8}. 
\]
++++
*  latexmath:[$\exp_{\rm poss}=3-(-1)+1 =5$], e eles explicitamente são: 
+
[latexmath]
++++
\[
-1, \quad0, \quad 1, \quad 2 \quad \mbox{e} \quad 3;
\]
++++

* latexmath:[${\rm NumR}_{+}=4\times 5 =20$], e eles são: 
+
[latexmath]
++++
\[
\frac{1}{2}\times 2^{\rm exp}, \quad\frac{5}{8}\times 2^{\rm exp}, \quad \frac{3}{4}\times 2^{\rm exp} \quad \mbox{e}\quad \frac{7}{8}\times 2^{\rm exp}, \quad {\rm exp}\in\{-1,0,1,2,3\}. 
\]
Ou seja, realmente temos os seguintes números: 
\[\hspace*{-1cm}
\begin{array}{llllll}
\frac{1}{2}\times 2^{-1} =\frac{1}{4}, &\frac{1}{2}\times 2^{0} =\frac{1}{2}, &
\frac{1}{2}\times 2^{1} =1, & \frac{1}{2}\times 2^{2} =2, & \frac{1}{2}\times 2^{3} =4,\\
\\
\frac{5}{8}\times 2^{-1} =\frac{5}{16}, & \frac{5}{8}\times 2^{0} =\frac{5}{8}, & 
\frac{5}{8}\times 2^{1} =\frac{5}{4}, & \frac{5}{8}\times 2^{2} =\frac{5}{2}, & \frac{5}{8}\times 2^{3} =5, \\\\
\frac{3}{4}\times 2^{-1} =\frac{3}{8}, & \frac{3}{4}\times 2^{0} =\frac{3}{4}, & \frac{3}{4}\times 2^{1} =\frac{3}{2}, & \frac{3}{4}\times 2^{2} =3, & \frac{3}{4}\times 2^{3} =6,  \\\\
\frac{7}{8}\times 2^{-1} =\frac{7}{16}, & \frac{7}{8}\times 2^{0} =\frac{7}{8}, & \frac{7}{8}\times 2^{1} =\frac{7}{4}, & \frac{7}{8}\times 2^{2} =\frac{7}{2}, & \frac{7}{8}\times 2^{3} =7.
\end{array}
\]
++++


* latexmath:[${\rm NumR}_{\rm T}=2\times 20 + 1 = 41$], e eles explicitamente são: 
+
[latexmath]
++++ 
\[\hspace*{-1.25cm}
\begin{array}{rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr}
-7,&-6,&-5,&-4,&-\frac{7}{2},&-3,&-\frac{5}{2},&-2,&-\frac{7}{4},& -\frac{3}{2},\\\\
-\frac{5}{4},&-1,&-\frac{7}{8},&-\frac{3}{4},&-\frac{5}{8},&-\frac{1}{2},&-\frac{7}{16},&-\frac{3}{8},&-\frac{5}{16},&-\frac{1}{4},&0\\
\\
\frac{1}{4},&\frac{5}{16},&\frac{3}{8},&\frac{7}{16},&\frac{1}{2},&\frac{5}{8},&\frac{3}{4},&\frac{7}{8},&1,&\frac{5}{4},\\\\
\frac{3}{2},&\frac{7}{4},&2,&\frac{5}{2},&3,&\frac{7}{2},&4,&5,&6,&7\end{array}
\]
++++
--
+
Mais ainda, para
+
[latexmath]
++++
\[
{\rm SPF}(2,3,-1,3) =\left\{x \in \mathbb{R}: x=\pm 0.d_1 d_2 d_3 \times 2^{\exp} \right\}.
\] 
++++
+
Temos que, *Underflow* e *Overflow* são os intervalos ilustrados na seguinte figura:
+
image::images/cap1/over_under.eps[scaledwidth="100%"] 

.. Se consideramos latexmath:[$\beta=10$, $n=3$, $\exp_{\rm min}=-5$ e $\exp_{\rm max}=5$].  Então, temos que:
+
[latexmath]
++++
\[
{\rm SPF}(10,3,-5,5) =\left\{x \in \mathbb{R}: x=\pm 0.d_1 d_2 d_3 \times 2^{\exp} \right\}.
\] 
onde
\[
 d_i \in\{0,1,2,3,4,5,6,7,8,9\}, \mbox{ para } i=2,3 , \quad d_1\neq 0, \quad \exp \in [-5,5].
\]
++++ 
+
Logo,
+
--
* latexmath:[${\rm m}=0.100 \times 10^{-5}= 10^{-6}$];
* latexmath:[${\rm M}=0.999 \times 10^{5}= 99900$];
* latexmath:[${\rm mantissas}_{\rm poss}=(10-1)\times 10^{3-1}= 900$];
* latexmath:[$\exp_{\rm poss}=5-(-5)+1=11$];
* latexmath:[${\rm NumR}_{+}=900\times 11=9900$];
* latexmath:[${\rm NumR}_{\rm T}=2\times 9900 + 1 = 19801$].
--
+
Mais ainda, para
+
[latexmath]
++++
\[
{\rm SPF}(10,3,-5,5) =\left\{x \in \mathbb{R}: x=\pm 0.d_1 d_2 d_3 \times 10^{\exp} \right\}.
\] 
++++
+
Temos que, *Underflow* e *Overflow* são os intervalos ilustrados na seguinte figura:
+
image::images/cap1/over_under1.eps[scaledwidth="100%"] 
====

[NOTE]
.Nota 1.5
====
.. Como podemos ver no exemplo acima, o conjunto de números  de ponto
   flutuante latexmath:[${\rm SPF}(\beta,n,\exp_{{\rm min}},
   \exp_{{\rm max}})$] é discreto, e não contínuo como o conjunto dos
   números reais.   Ou seja, já não temos mais o conceito  que entre
   dois números  pertencente a latexmath:[${\rm
   SPF}(\beta,n,\exp_{{\rm min}}, \exp_{{\rm max}})$] sempre existe
   um outro número pertencente a latexmath:[${\rm
   SPF}(\beta,n,\exp_{{\rm min}}, \exp_{{\rm max}})$];

.. Algumas linguagens de programação permitem que as variáveis possam
   ser declaradas com precisão dupla,  e isto implica que a variável
   utilizará o dobro de dígitos disponíveis na mantissa,  o que
   acarretará no aumento do tempo de execução e requerimentos de
   memória (`long double` em C).  Isto é devido a que a aritmética de
   precisão dupla é usualmente feito usando *software*,  enquanto que
   precisão simples é feito pelo *hardware*.

====




=== Erros Absoluto e Relativo

Nas medições científicas, quando se aproxima um número real
latexmath:[$x$ mediante outro número $\overline{x}$, o erro que
resulta é $x-\overline{x}$], isto é:

[latexmath]
++++
\[
{\rm Erro}= x-\overline{x}.
\]
++++

Porém, dependendo da magnitude da quantidade que está sendo medida,
tal erro pode ser aceitável ou não. Por exemplo, se perguntamos a uma
pessoa: Qual é a distância entre a Terra e a Lua? e esta responde:
384401 kms, seria algo assombroso, pois o erro somente será de 1 km,
porém este tipo de erro não seria aceitável no pouso de uma aeronave.
Por este motivo precisamos estabelecer conceitos fundamentais para o
bom entendimento desta teoria.


Definição 1.3:: O *erro absoluto* de aproximar latexmath:[$x$, denotado por ${\rm
EA}_x$, é a diferença entre o valor exato de um número $x$ e o seu
valor aproximado $\overline{x}$], isto é:
+
[latexmath]
++++
\[
{\rm EA}_x = x-\overline{x}.
\]
++++

[CAUTION]
.Atenção 1.3
====
Na maioria das vezes, o valor exato de um número não está disponível,
por este motivo, é necessário trabalhar com um limitante superior ou
uma estimativa para o módulo do erro absoluto.
====

.{zwsp}
====
.. Dados  latexmath:[$\pi$ e  $\overline{\pi}$, com $\overline{\pi}$
   sendo qualquer valor no intervalo aberto $(3.14, 3.15)$]. Então, temos que 
+
[latexmath]
++++
\[
|{\rm EA}_{\pi}|= | \pi - \overline{\pi}|< 0.01;
\]
++++
.. Dados latexmath:[$x$ e $\overline{x}$, com $\overline{x}= 332.9$] tal que:
+ 
[latexmath]
++++
\[
|{\rm EA}_x|=|x-\overline x|< 0.1.\quad \mbox{Então} \quad x\in (332.8, 333);
\]
++++
.. Dados latexmath:[$y$ e $\overline{y}$, com $\overline{y}= 1.4$] tal que:
+ 
[latexmath]
++++
\[
|{\rm EA}_y|=|y-\overline y|<0.1.\quad\mbox{Então}\quad y\in (1.3,1.5). 
\]
++++
====

Embora, os números latexmath:[$x$ e $y$] estejam sendo representados
com a mesma precisão, necessitamos saber a ordem de grandeza deles
para obter uma maior precisão em nossos cálculos. Por este motivo,
precisamos conhecer o conceito de *erro relativo*.



Definição 1.4:: O *erro relativo* de aproximar latexmath:[$x$, denotado por  ${\rm
ER}_x$, é o erro absoluto, de aproximar $x$], dividido pelo seu valor aproximado, isto é:
+
[latexmath]
++++
\[
{\rm ER}_x = \frac{{\rm EA}_x}{\overline{x}} = \frac{x- \overline{x}}{\overline{x}}.
\]
++++

Podemos notar que o erro relativo proporciona mais informações sobre a
qualidade do erro que estamos cometendo num determinado cálculo, já
que a ordem de grandeza do valor calculado é contemplada.

.{zwsp}
====
Do exemplo anterior, temos que:
[latexmath]
++++
\[
|{\rm ER}_x|= \frac{|{\rm EA}_x|}{|\overline{x}|}< \frac{0.1}{332.9} \approx 3.003\times 10^{-4}
\]
\[
|{\rm ER}_y|= \frac{|{\rm EA}_y|}{|\overline{y}|}< \frac{0.1}{1.4} \approx 0.071
\]
++++
Portanto, latexmath:[$x$ será representado com maior precisão que $y$].
====


//Em geral, nos procedimentos numéricos se gera uma sequencia de soluções aproximadas as quais no limite tendem ou não para a solução do problema.

==== Erros num Sistema de Ponto Flutuante

A representação de num número num sistema de ponto flutuante depende do
computador usado, pois o seu sistema estabelecerá a base numérica
adotada, o número de dígitos da mantissa, etc.

Sejam um computador que trabalha com latexmath:[${\rm SPF}(10,n, \exp_{\rm min}, \exp_{\rm max})$ e um número real $x \in [m,\,M\]$. Então, $x$] pode ser reescrito como

[latexmath]
++++
\[
x=f_x\times 10^{\exp} + g_x\times 10^{\exp -n}
\]
++++
onde latexmath:[$0.1\leq f_x <1$ e $0\leq g_x <1$].  



Por exemplo, consideremos latexmath:[${\rm SPF}(10,4,-5,5)$ e $x=123.45$], temos que
[latexmath]
++++
\[
{\rm m}=10^{-6},\quad {\rm M}=99990\quad \mbox{e}\quad x \in [{\rm m}, {\rm M}].
\]
Logo,
\[
\begin{array}{rcl}
x&=&0.12345\times 10^{3}
\end{array}
\]
No entanto, no sistema ${\rm SPF}(10,4,-5,5)$, temos que
\[
n=4,\quad \exp_{\min}=-5,\quad \exp_{\max}=5 \quad \mbox{e}\quad 3=\exp\in [\exp_{\min},\exp_{\max}]
\]
Ou seja, a mantissa neste sistema somente atura 4 dígitos, assim $x$ não poderá ser representado em ${\rm SPF}(10,4,-5,5)$. Para resolver este problema, precisamos
 trabalhar com uma aproximação de $x$, e obteremos esta aproximação reescrevendo $x$:
\[
\begin{array}{rcl}
x&=&0.12345\times 10^{3}\\
&=&0.1234\times 10^{3} + 0.00005\times 10^{3}
\\
&=&0.1234\times 10^{3} + 0.5\times 10^{3-4}
\\
&=&0.1234\times 10^{3} + 0.5\times 10^{-1}
\end{array}
\]
Assim, neste caso
\[
f_x=0.1234 \quad \mbox{e} \quad g_x= 0.5.  
\]
++++
Logo, o problema agora é de como considerar latexmath:[$g_x$]
dentro da mantissa, e estabelecer o erro absoluto (ou relativo) máximo
cometido nesta aproximação. Para resolver este problema, podemos adotar um dos seguintes critérios: 
[latexmath]
++++
\[
\mbox{truncar ou arredondar.}\]
++++

===== Erros no Truncamento

Quando consideramos num sistema de punto flutuante que trabalha com aritmética de *truncamento*, o valor latexmath:[$g_x\times
10^{\exp -n}$] é *desprezado*. Portanto, o valor aproximado  é dado por:

[latexmath]
++++
\[
\overline{x}=f_x\times 10^{\exp}.
\]
Logo, $|g_x|<1$ implica que
\[
\begin{array}{rcl}
|{\rm EA}_x| &=& |x-\overline{x}| =  |g_x| \times 10^{\exp -n} < 10^{\exp -n}.
\end{array}
\]
Além disso, $1< \dfrac{1}{|f_x|} \leq \dfrac{1}{0.1}$ implica que
\[
\begin{array}{rcl}
|{\rm ER}_x| &=& \dfrac{|{\rm EA}_x|}{|\overline{x}|} =  \dfrac{|g_x| \times 10^{\exp -n}}{|f_x| \times 10^{\exp} } < \dfrac{10^{\exp -n}}{0.1\times 10^{\exp}} = 10^{-n+1}.
\end{array}
\]
++++

.{zwsp}
====
Para latexmath:[${\rm SPF}(10,4,-5,5)$, que trabalha com aritmética de truncamento, e $x=123.45$] temos que:
[latexmath]
++++
\[
\bar x=f_x\times 10^{\exp}=0.1234 \times 10^3.
\]
\[
{\rm EA}_x = x-\overline{x}=0.12345 \times 10^3-0.1234 \times 10^3=(0.12345 -0.1234)\times 10^3=0.00005\times 10^3=0.05.
\]
\[
{\rm ER}_x = \dfrac{{\rm EA}_x}{\overline{x}}=\frac{0.05}{0.1234 \times 10^3}\approx 4.0518\times 10^{-4}.
\]
++++
====

===== Erros no Arredondamento

Quando consideramos um sistema de punto flutuante que trabalha com aritmética de *arredondamento*, latexmath:[$f_x$ é modificado
para levar em conta $g_x$]. A forma mais usada é o
arredondamento simétrico:

[latexmath]
++++
\[
\overline{x} = \left\{
 \begin{array}{ccl} 
f_x\times 10^{\exp}, && \mbox{se}\quad |g_x|< \dfrac{1}{2};\\
&&\\
f_x\times 10^{\exp} + 10^{\exp-n}, && \mbox{se}\quad |g_x| \geq \dfrac{1}{2}.
\end{array}
\right.
\]
++++

Em outras palavras, se latexmath:[$|g_x|< \dfrac{1}{2}$, então $g_x\times 10^{\exp-n}$ é
{\bf desprezado}, caso contrário somamos o número $1$ ao último dígito de
$f_x$]. Logo, 

* se latexmath:[$|g_x|<\frac{1}{2}$], então
+
[latexmath]
++++
\[
\begin{array}{l}
|{\rm EA}_x|= |x-\overline{x}| =|g_x|\times 10^{\exp-n} < \dfrac{1}{2}\times 10^{\exp-n};\\
\\
|{\rm ER}_x| = \dfrac{|{\rm EA}_x|}{|\overline{x}|} =  \dfrac{|g_x| \times 10^{\exp -n}}{|f_x| \times 10^{\exp }} < 
\dfrac{0.5\times 10^{\exp -n}}{0.1\times 10^{\exp}} = \dfrac{1}{2} \times 10^{-n+1};
\end{array}
\]
++++
* se latexmath:[$|g_x|\geq\frac{1}{2}$], então
+
[latexmath]
++++
\[
\begin{array}{rcl}
|{\rm EA}_x|&=& |x-\overline{x}| =\left|(f_x\times 10^{\exp} + g_x\times 10^{\exp -n}) - (f_x\times 10^{\exp} +10^{\exp -n}) \right|\\                  \\
      &= &\left| g_x \times 10^{\exp-n} - 10^{\exp-n}\right|=  |g_x -1|\times 10^{\exp-n} \\\\
&\leq& \frac{1}{2} \times 10^{\exp-n}\\
&&\\
|{\rm ER}_x| &=& \dfrac{|{\rm EA}_x|}{|\overline{x}|} =  \dfrac{\frac{1}{2} \times 10^{\exp -n}}{|f_x \times 10^{\exp}+ 10^{\exp}|} <  \dfrac{\frac{1}{2}\times 10^{\exp -n}}{|f_x|\times 10^{\exp}} 
\\\\
&<& \dfrac{\frac{1}{2}\times 10^{\exp -n}}{0.1\times 10^{\exp}}<  \frac{1}{2} \times 10^{-n+1}
\end{array}
\]
Portanto, em ambos casos obtemos que os erros absolutos e relativos podem ser limitados pelas seguintes expressões:
\[
|{\rm EA}_x| \leq \frac{1}{2} \times 10^{\exp-n}\qquad\mbox{e}\qquad |{\rm ER}_x|< \frac{1}{2} \times  10^{-n+1}.
\]
++++
.{zwsp}
====
Para latexmath:[${\rm SPF}(10,4,-5,5)$, que trabalha com aritmética de arredondamento, e $x=123.45$] temos que:
[latexmath]
++++
\[
\bar x=f_x\times 10^{\exp}+10^{\exp-n}=0.1234 \times 10^3+ 10^{3-4}=0.1234 \times 10^3+ 10^{-1}=0.1235\times 10^3.
\]
\[
{\rm EA}_x = x-\overline{x}=0.12345 \times 10^3-0.1235 \times 10^3=(0.12345 -0.1235)\times 10^3=-0.00005\times 10^3=-0.05.
\]
\[
{\rm ER}_x = \dfrac{{\rm EA}_x}{\overline{x}}=\frac{-0.05}{0.1235 \times 10^3}\approx -4.0488\times 10^{-4}.
\]
++++
====
[NOTE]
.Nota 1.6
====
Embora, a geração de erros seja menor quando optamos por fazer
arredondamento, isto demanda de um  maior tempo de execução, e por
este motivo o truncamento é mais usado.
====

==== Propagação dos erros

Quando efetuamos operações num latexmath:[${\rm SPF}(\beta,n,
\exp_{\rm min}, \exp_{\rm max})$], como por exemplo:

[latexmath]
++++
\[
x=[(y+w)-z]+v
\]
++++

devemos levar  em conta a propagação dos erros, isto é, como o erro
numa operação se propaga ao longo das próximas  operações. Assim, o
erro total numa operação é composto pelo erro da aproximação dos
fatores e pelo erro no resultado da operação. 



.{zwsp}
====
Sejam latexmath:[$x=0.457\times 10^4$, $y=0.9168\times 10^2 \in {\rm SPF}(10,4, \exp_{\rm min}, \exp_{\rm max})$]. Calculemos latexmath:[$x+y$ e $x\times y$].

Solução::

.. latexmath:[$x+y$]: Para realizar uma soma em aritmética de ponto
   flutuante, é necessário que os números estejam alinhados, em
   relação ao ponto decimal. Assim, a mantissa do número de menor
   expoente deve ser deslocada para a direita as posições necessárias,
   isto é, o deslocamento deve ser de um número de casas decimais
   igual à diferença entre os dois expoentes. Logo,  latexmath:[$x$ e
   $y$] serão reescritos da seguinte forma
+
[latexmath]
++++
\[
x=0.457\times 10^4\quad \mbox{ e } \quad y=0.009168\times 10^4
\]
Desta forma, 
\[
x+y=(0.457+ 0.009168)\times 10^4=0.466168\times 10^4.
\]
++++
+
Como latexmath:[$n=4$], o resultado exato desta operação deve ser
arredondado ou truncado, para poder pertencer a latexmath:[${\rm
SPF}(10,4, \exp_{\rm min}, \exp_{\rm max})$]. Assim,
+
--
... se arredondamos, temos que: 
+
[latexmath]
++++
\[
\overline{x+y}= 0.4662\times 10^4;
\]
++++

... se truncamos, temos que: 
+
[latexmath]
++++
\[
\overline{x+y}= 0.4661\times 10^4.
\]
++++
--

.. latexmath:[$x\times y$]: Para realizar o produto de dois números
   procedemos da forma habitual.
+
[latexmath]
++++
\[
x \times y =(0.457\times 10^4) \times(0.9168\times 10^2) = (0.457\times 0.9168)\times 10^6 = 0.4189776 \times 10^6
\]
++++
+
devido a que em nosso sistema latexmath:[$n=4$], o resultado deve de
ser arredondado ou truncado. Assim, 
+
--
... Se arredondamos, temos que: 
+
[latexmath]
++++
\[
\overline{x\times y}= 0.4190\times 10^6;
\]
++++

... Se truncamos, temos que: 
+
[latexmath]
++++
\[
\overline{x \times y}= 0.4189\times 10^6.
\]
++++
--
====


Do exemplo anterior, observamos que, embora os números envolvidos na
operação sejam representados num sistema de ponto flutuante
normalizado, não podemos esperar que o resultado também possa ser
representado neste sistema.

Quando trabalhamos num processo numérico, o processamento dos dados
pode envolver um certo número de operações elementares. Existem casos
em que o erro não é significativo para a solução do problema, porém em
geral, é importante saber como os erros estão se propagando, pois isto
pode ou não afetar os resultados obtidos. 

... Caso o erro esteja se acumulando a uma taxa crescente, se diz que
o erro é *ilimitado*, e a sequência de operações é considerada
*instável*; o item(a) da figura abaixo ilustra este fato.

... Caso contrário, o erro está se acumulando a uma taxa
decrescente, se diz que o erro é *limitado*, e a sequência de
operações é considerada *estável*; o item(b) da figura abaixo ilustra
este fato.


image::images/cap1/Erro_lim_ilim.eps[scaledwidth="80%"]


.{zwsp}
====
Usando latexmath:[${\rm SPF}(10,4, \exp_{\rm min}, \exp_{\rm max})$], com aritmética de truncamento, calculemos o valor da seguinte soma:
[latexmath]
++++
\[
S= \sum\limits^{3}_{i=1}(x_i+y_i),\qquad \mbox{com}\quad x_i=0.51909\quad y_i=4.4878\quad \forall\,i=1,2,3. 
\]
++++

Solução:: Desde que estamos trabalhando em latexmath:[${\rm SPF}(10,4,
\exp_{\rm min}, \exp_{\rm max})$], temos que
+
[latexmath]
++++
\[
x_i=0.51909\quad\Rightarrow \quad  \overline{x}_i=0.519  \quad \mbox{e}\quad  y_i=4.4878\quad\Rightarrow \quad \overline{ y}_i=0.4487\times 10^{1} 
\]
++++
+
para todo latexmath:[$i=1,2,3.$]

... Para latexmath:[$i=1$] temos que: 
+
[latexmath]
++++
\[S_1=x_1 + y_1=0.51909+4.4878 = 0.500689 \times 10^1
\]
\[
\overline{S}_1=\overline{x}_1 + \overline{y}_1= 0.519 + 0.4487\times 10^{1}=0.5006 \times 10^1 
\]
Logo, o Erro absoluto é dado por:
\[
{\rm EA}_{1}=0.500689 \times 10^1- 0.5006\times 10^1= 0.000089\times 10^1= 0.89 \times 10^{-3}. 
\]
++++

... Para latexmath:[$i=2$] temos que: 
+
[latexmath]
++++
\[
S_2=(x_2 + y_2)+ (x_1 + y_1)=0.500689 \times 10^1 + 0.500689 \times 10^1= 0.1001378\times 10^2
\]
\[
\overline{S}_2= (\overline{x}_2 + \overline{y}_2)+ (\overline{x}_1 + \overline{y}_1)=0.5006 \times 10^1+ 0.5006 \times 10^1=0.10012 \times 10^2 \approx 0.1001 \times 10^2
\]
Logo, o Erro absoluto é dado por:
\[
{\rm EA}_{2}=0.1001378\times 10^2- 0.1001 \times 10^2= 0.0000378\times 10^2= 0.378 \times 10^{-2}. 
\]
++++

... Para latexmath:[$i=3$] temos que: 
+
[latexmath]
++++
\[
S_3=(x_3 + y_3)+(x_2 + y_2)+ (x_1 + y_1)= 0.1502067 \times 10^2
\]
\[
\overline{S}_3=(\overline{x}_3 + \overline{y}_3)+ (\overline{x}_2 + \overline{y}_2)+ (\overline{x}_1 + \overline{y}_1)= 0.15018 \times 10^2 \approx 0.1501 \times 10^2
\]
Logo, o Erro absoluto é dado por:
\[
 {\rm EA}_{3}=0.1502067 \times 10^2- 0.1501 \times 10^2= 0.0001067\times 10^2= 0.1067 \times 10^{-1}. 
\]
++++
====

Neste exemplo, observamos que a medida que aumentam as operações de
adição e considerando a aritmética de ponto flutuante definida, o erro
absoluto cresce. Assim, a medida que latexmath:[$i$] cresce 
a sequência de operações pode torna-se instável.


.{zwsp}
====
Considere a sequência gerada por:
[latexmath]
++++
\[
x_{i+1}=\frac{1}{2} \left( x_i + \frac{2}{x_i} \right),\qquad \forall\, i=1,2,\ldots
\]
++++
Nesta sequência, estão envolvidas as operações de adição,
multiplicação e divisão, as quais são repetidas sucessivamente até
obter o valor aproximado de latexmath:[$x_i$, que deve ser uma solução
com a precisão desejada $\epsilon$].

Assim, o valor final latexmath:[$x_i$] possui um determinado tipo de
erro, o qual pode se propagar ao longo de todo o processo. Caso a
sequência convirja para um número, apesar dos erros cometidos na
obtenção de cada iteração, temos que a sequência de operações torna-se
estável. 

====



=== Recapitulando

Desde que na computação é importantíssimo entender o porque do
surgimento de erros nos resultados obtidos na execução de um
algoritmo, neste capítulo, aprendimos como  o *computador armazena* um
número dado.

Porém, para que esta aprendizagem aconteça de forma natural, nas
seções subsequentes, trabalhamos com o *sistema binário* e *sistema
decimal*, e lembramos como *converter* números da base 10 para a base 2, 
e vice-versa. Além disso, foram estabelecidos os conceitos de
*sistema de ponto flutuante normalizado*, *erro absoluto* e *erro
relativo*. 

Por último, mas não menos importante, realizamos *operações
aritméticas* com números de um *sistema de ponto flutuante* dado, e
entendemos  a *propagação de seus erros*.  Mais ainda, todos estes
conceitos foram ilustrados  com diversos exemplos.

No próximo capítulo, apresentaremos  as noções básicas e necessárias
sobre *vetores* em latexmath:[$\mathbb{R}^n$], já que esta teoria é
fundamental para o bom entendimento dos próximos capítulos. 

////
Sempre termine os arquivos com uma linha em branco.
////
